<center><h1>操作系统指纹探测技术 - 技术报告</h1></center>

## 3. 主动探测技术方案设计

### 3.1 主动探测技术原理

本次PROJECT对应的探测技术为主动探测，即基于TCP/IP 协议栈指纹探针的主动探测技术。

其基本原理为各个操作系统在设计与实现TCP/IP协议栈时, 对RFC文档做出了不同理解，导致各个操作系统在 TCP/IP协议的实现上的不同。通过对不同操作系统的TCP/IP协议栈实现存在细微差异,作为识别远程主机操作系统指纹。

为了达到较准确的识别目标服务器，课程内的指纹分析方法并不能满足这个需求。因此本项目在课程外参考开源软件`Nmap`，扩展了指纹分析方法，同时使用其自带的指纹数据库。



### 3.2 指纹与响应分析

下文将本项目检测的所有指纹响应，区分度由强到弱进行叙述。

#### 3.2.1 TCP Option分析

这个测试记录数据包中的TCP头选项。它保留了原始的顺序，还提供了一些关于选项值的信息。因为`RFC793`不需要任何特定的排序，所以实现通常会产生唯一的顺序。当所有这些排列与实现使用的不同选项值的数量组合在一起时，此测试提供了一个**区分度最强**的指纹信息方案。此测试的值是表示所使用的选项的字符串。有几个选项的参数紧跟在字符之后。受支持的选项和参数都显示在下表中。

| Option名                       | 对应字符 |
| ------------------------------ | -------- |
| End of Options List (EOL)      | L        |
| No operation (NOP)             | N        |
| Maximum Segment Size (MSS)     | M        |
| Window Scale (WS)              | W        |
| Timestamp (TS)                 | T        |
| Selective ACK permitted (SACK) | S        |

例如，字符串`M5B4NW3NNT11`表示包包含MSS选项(值0x5B4)和NOP。接下来是一个窗口缩放选项，其值为3，然后是两个nop。最后一个选项是时间戳，它的两个字段都不是零。



#### 3.2.2 TCP 初始化窗口值分析

这种分析方法只是记录接收到的数据包的16位TCP窗口大小。但是它**非常有效**，因为本人分析指纹数据库，发现此项测试至少有80个操作系统采用不同值。



#### 3.2.3 是否有响应分析

这个测试只记录目标是否对给定的探针有响应。可能的值是有相应和没有响应。

注意，此测试的**风险包括被防火墙丢弃的探针**。这将导致受试者指纹中的没有响应。然而，如果目标操作系统指纹在指纹数据库中是响应的话，此次检测将失效。因此**防火墙可以阻止正确的操作系统检测**。为了减少这个问题，参考指纹通常省略了来自IE和U1探测的R=Y测试，这两个探测是最有可能被删除的。

对所有TCP和UDP探针而言，它们都将发送给目标的开启端口或关闭端口，但不能被防火墙过滤掉。这表明**主动探测技术需要端口扫描的结果，以获取目标机的开启或关闭端口**。



#### 3.2.4 IP不分片位测试
IP报头包含一个bit位，它禁止路由器对数据包进行分段。如果包太大，路由器无法处理，则只能丢弃它(并理想地返回“无法到达的目的地，需要分片”响应)。有的操作系统初值为 0 (允许分片)或1, 有些操作系统在满足一定条件时设置为 0。



#### 3.2.5 IP初始TTL估计

由于**防火墙和NAT设备通常阻止未经请求的UDP数据包**，所以到的UDP探测没有响应是很常见的，这阻止软件了解本机到目标有多少跳。但是，由于常见的TTL值分布得很好，并且目标之间的距离很少超过20跳，因此我们可以做出很好的猜测。大多数系统发送初始TTL为32、60、64、128或255的数据包。所以软件将响应中接收到的TTL值四舍五入为32、64、128或255。但为了易于实现，60不在这个列表中，因为它不能可靠地与64区分开来。



#### 3.2.6 显式拥塞通知分析

此测试仅用于TCP中的ECN探针，该探针是一个SYN包，它包含CWR和ECE拥塞控制标志。当接收到响应SYN/ACK时，将检查这些响应是否满足一下4中情况：

	1. 只设置了ECE位(而不是CWR)，表明此主机支持ECN；
	2. 这两个位都没有设置。目标不支持ECN；
	3. 目标不支持ECN，但它会回显它认为是保留位的内容；
	4. 其他的剩余组合。



#### 3.2.7 TCP序列号与确认号关联分析

这个测试检查TCP报头中的32位序列号字段。不像其他一些测试那样记录字段值，这个测试检查它如何与引起响应的探针的TCP确认号进行比较。然后它记录适当的值，检测是否满足一下情况：

	1. 序列号为零；
	2. 序列号与发送的探针中确认号相同；
	3. 序列号等于发送的探针中确认号+1；
	4. 其他值。



#### 3.2.8 TCP确认号与序列号关联分析

这个测试与3.2.7相同，只是它测试响应中的应答号与相应探测中的序列号之间的比较，检测是否满足一下情况：

	1. 确认号为零；
	2. 确认号与探针中的序列号相同；
	3. 确认号与探针中的序列号+ 1相同；
	4. 其他值



#### 3.2.9 TCP标志位分析

该字段记录响应中的TCP标记。每个字母代表一个标志，它们的顺序与TCP包相同(从左边的高位到低位)。因此，值AS表示ACK和SYN位集，而值SA是非法的(顺序错误)。可能的标志如表8.6所示。

| Flag name            | Flag byte value |
| -------------------- | --------------- |
| ECN Echo (ECE)       | 64              |
| Urgent Data (URG)    | 32              |
| Acknowledgment (ACK) | 16              |
| Push (PSH)           | 8               |
| Reset (RST)          | 4               |
| Synchronize (SYN)    | 2               |
| Final (FIN)          | 1               |



#### 3.2.10 ICMP响应值分析

ICMP回送应答(类型为零)包的代码值应该为零。但是有些实现不正确地发送其他值，特别是当echo请求有非零代码时(就像IE测试那样)。两个探测的响应代码值被合并为CD值，可能的情况如下：

	1. 两个代码值都是零；
	2. 这两个代码值与相应探针中的相同；
	3. 当它们都使用相同的非零数；
	4. 任何其他组合。



### 3.3 探针设计

为了最有效得覆盖以上所有指纹分析方案，总共设计了16个探针。分为13个TCP探针（又分为6个SEQ探针、6个普通探针和1个拥塞控制探针）、2个ICMP探针和1个UDP探针。



#### 3.3.1 TCP SEQ探针

SEQ探针包括一系列6个TCP探针来分析响应的8个指纹信息。探测被**精确地间隔100毫秒**发送，所以总的时间是500毫秒。准确的定时非常重要，因为我们检测的一些序列算法(初始序列号和TCP时间戳)是依赖于时间的。选择这个时间值的时间为500毫秒，这样我们就可以可靠地检测常见的TCP时间戳序列。


每个探测都是一个TCP SYN数据包，连接到远程机器上一个检测到的**开放端口**。序列和确认号码是随机的。


这些包使用的TCP选项和TCP窗口字段值各不相同。下面的列表提供了所有6个包的选项和值。列出的窗口字段值不反映窗口缩放。

	1. 窗口规模(10)，NOP, MSS(1460)，时间戳(TSval: 0xFFFFFFFF;TSecr: 0)，允许SACK。窗口字段是1。
	2. MSS(1400)，窗口规模(0)，SACK允许，时间戳(TSval: 0xFFFFFFFF;TSecr: 0),终点。窗口字段是63。
	3. 时间戳(TSval: 0xFFFFFFFF;TSecr: 0)， NOP, NOP，窗口规模(5)，NOP, MSS(640)。窗口字段是4。
	4. 允许SACK，时间戳(TSval: 0xFFFFFFFF;TSecr: 0)，窗口规模(10)，EOL。窗口字段是4。
	5. MSS (536)， SACK允许，时间戳(TSval: 0xFFFFFFFF;TSecr: 0)，窗口规模(10)，EOL。窗口字段是16。
	6. MSS (265)， SACK允许，时间戳(TSval: 0xFFFFFFFF;TSecr: 0).窗口字段为512。

这些测试的结果包括3种探测结果。第一个是OPS包含每个探测接收到的TCP选项，第二个是WIN行包含探测响应(名为W1到W6)的窗口大小，最后是TCP普通测试。共包含8种测试。



#### 3.3.2 TCP普通探针

普通探针包含6个探针，每个探针的描述如下:

	1. 向一个**开放端口**发送一个TCP null(没有设置任何标志)包，该包的IP DF位设置和一个128的窗口字段。
	2. 将设置了SYN、FIN、URG和PSH标志的TCP包和256个窗口字段发送到一个**开放端口**。未设置IP DF位。
	3. 将一个带有IP DF和一个窗口字段为1024的TCP ACK包发送到一个**开放端口**。
	4. 发送一个没有IP DF和窗口字段为31337的TCP SYN包到一个**关闭端口**。
	5. 发送一个带有IP DF和一个窗口字段为32768的TCP ACK包到一个**关闭端口**。
	6. 将设置了FIN、PSH和URG标志以及窗口字段为65535的TCP包发送到一个**关闭端口**。未设置IP DF位。



#### 3.3.3 TCP拥塞控制探针

此探针测试目标TCP/IP协议栈中的显式拥塞通知(ECN)支持。ECN是一种改善互联网性能的方法，它允许路由器在开始丢弃数据包之前发出拥塞问题的信号。它记录在`RFC3168`中。该探针的确认号为零,序列号是随机的,窗口大小字段是3。TCP选项中依次设置Window Scale为10，NOP，MSS为1460，NOP，NOP。探测器被发送到一个**开放端口**。


如果接收到响应，则执行并记录R、DF、TG、W、O和CC测试。



#### 3.3.4 ICMP探针

IE测试包括向目标发送两个ICMP echo请求包。第一个是IP DF位集，TOS值为0，代码为9，序列号295和ICMP请求标识符，数据有效负载为120字节的0x00。


第二个ICMP探针与此类似，只是代码为0，发送了150字节的数据，ICMP请求ID和序列号比前一个加1。


这两种探针的结果合并成R、DFI、TG和CD测试。



#### 3.3.5 UDP探针

这个探针会被发送到一个**关闭端口**。重复300次0x43作为数据字段。如果端口是真正关闭的，并且没有防火墙，那么将期望接收ICMP端口不可到达的消息。然后对该响应进行R、DF和TG测试。



## 4. 软件结构设计

分析上述需求，软件可划分为三个部分：嗅探模块，发送模块和控制模块。由于本项目提供了web demo，所以也实现了一个简单的web模块：

1. 发送模块提供探针的存储并执行发送行为功能，使用`raw-socket`实现。

2. 嗅探模块提供监听探针的响应包并对其进行分析，基于`libpcap`，由`nodejs`与其交互。

3. 控制模块提供定时、顺序和异步调用发送模块，同时接受嗅探模块的指纹信息并合并。

4. web模块提供简单的api和界面。

由于软件整体规模很小，所以适合个人快速开发。软件周期模型选用快速迭代开发，同时选择`nodejs`作为主体开发语言。
